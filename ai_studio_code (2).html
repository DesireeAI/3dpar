<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand Interactive Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* UI Overlay */
        #ui-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
            color: white;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 10;
        }

        .row { display: flex; justify-content: space-between; align-items: center; }
        
        h3 { margin: 0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; color: #aaa; }

        /* Buttons */
        .btn-group { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 5px; }
        button {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            white-space: nowrap;
        }
        button.active { background: #00d2ff; color: #000; font-weight: bold; }
        button:active { transform: scale(0.95); }

        /* Color Picker */
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            background: none;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; border: 2px solid rgba(255,255,255,0.5); }

        /* Camera Feed (Hidden, used for processing) */
        #video-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px; 
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }
        
        /* Start Button overlay */
        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            text-align: center;
        }
        #start-btn {
            background: linear-gradient(45deg, #00d2ff, #3a7bd5);
            font-size: 20px;
            padding: 15px 40px;
            margin-top: 20px;
            border-radius: 30px;
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.4);
        }
        .status { margin-top: 10px; color: #888; font-size: 12px; }
    </style>
</head>
<body>

    <!-- Camera Feed -->
    <video id="video-feed" playsinline></video>

    <!-- Start Overlay -->
    <div id="start-overlay">
        <h1 style="color:white; margin-bottom:10px;">Particle Flow</h1>
        <p style="color:#ccc; max-width: 300px;">Show your hand to camera.<br>Close hand to shrink, Open to expand.</p>
        <button id="start-btn">Start Camera</button>
        <div class="status" id="status-text">Waiting for permissions...</div>
    </div>

    <!-- Controls -->
    <div id="ui-container" style="display:none;">
        <div class="row">
            <h3>Shape</h3>
            <input type="color" id="color-picker" value="#00d2ff">
        </div>
        <div class="btn-group">
            <button class="mode-btn active" data-mode="atoms">Atoms</button>
            <button class="mode-btn" data-mode="hearts">Hearts</button>
            <button class="mode-btn" data-mode="flowers">Flowers</button>
            <button class="mode-btn" data-mode="fireworks">Fireworks</button>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- 1. CONFIG & STATE ---
        const config = {
            particleCount: 2500,
            baseColor: new THREE.Color('#00d2ff'),
            mode: 'atoms',
            handTension: 0.5, // 0 (closed) to 1 (open)
            handDetected: false
        };

        // --- 2. THREE.JS SETUP ---
        const scene = new THREE.Scene();
        // Add subtle fog for depth
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // optimize for mobile
        document.body.appendChild(renderer.domElement);

        // --- 3. PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(config.particleCount * 3);
        const targetPositions = new Float32Array(config.particleCount * 3);
        
        // Initialize positions randomly
        for (let i = 0; i < config.particleCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 50;
            targetPositions[i] = positions[i];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Create a soft glowing texture programmatically
        const getTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(255,255,255,0.5)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        };

        const material = new THREE.PointsMaterial({
            size: 0.5,
            map: getTexture(),
            color: config.baseColor,
            transparent: true,
            opacity: 0.9,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 4. MATH SHAPES GENERATORS ---
        function calculateTargets(time) {
            const count = config.particleCount;
            const mode = config.mode;
            
            // Hand influence factors
            // If hand open (1.0) -> Scale 1.5x. If closed (0.0) -> Scale 0.2x
            // Default (no hand) -> 0.8
            const rawTension = config.handDetected ? config.handTension : 0.6;
            const scaleFactor = 0.2 + (rawTension * 1.8); 
            
            // Adjust particle size based on tension
            material.size = 0.2 + (rawTension * 0.6);

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                let x, y, z;

                if (mode === 'atoms') {
                    // Spherical distribution with orbital rings
                    const r = 10 * scaleFactor;
                    const phi = Math.acos( -1 + ( 2 * i ) / count );
                    const theta = Math.sqrt( count * Math.PI ) * phi;
                    
                    // Add some noise/orbit movement
                    const noise = Math.sin(time + i) * 0.5;
                    
                    x = r * Math.cos( theta ) * Math.sin( phi ) + noise;
                    y = r * Math.sin( theta ) * Math.sin( phi ) + noise;
                    z = r * Math.cos( phi );

                } else if (mode === 'hearts') {
                    // 3D Heart formula
                    const t = (i / count) * Math.PI * 2; 
                    // Distribute points inside volume roughly
                    const r = 0.5 * scaleFactor; 
                    
                    // Parametric Heart
                    // We scramble index to fill volume
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    // Base heart shape
                    let hx = 16 * Math.pow(Math.sin(theta), 3);
                    let hy = 13 * Math.cos(theta) - 5 * Math.cos(2*theta) - 2 * Math.cos(3*theta) - Math.cos(4*theta);
                    let hz = 4 * Math.cos(theta) * Math.sin(phi) * 4; // Add depth

                    x = hx * r;
                    y = hy * r;
                    z = hz * r;

                } else if (mode === 'flowers') {
                    // Phyllotaxis (Sunflower spiral)
                    const spread = 0.5 * scaleFactor;
                    const angle = i * 137.5 * (Math.PI / 180);
                    const r = spread * Math.sqrt(i);
                    
                    // Add a wave to make it 3D
                    const zOffset = Math.sin(r * 0.5 - time) * 5 * scaleFactor;

                    x = r * Math.cos(angle);
                    y = r * Math.sin(angle);
                    z = zOffset;

                } else if (mode === 'fireworks') {
                    // Explosion bursts
                    // Use modulo to create multiple bursts
                    const burstIndex = i % 5; // 5 concurrent bursts
                    const pIndex = Math.floor(i / 5);
                    
                    // Explosion logic
                    const speed = (time * 2) % 10; // looping time 0-10
                    const radius = speed * (3 + Math.random()) * scaleFactor;
                    
                    const phi = Math.acos( -1 + ( 2 * pIndex ) / (count/5) );
                    const theta = Math.sqrt( (count/5) * Math.PI ) * phi;

                    // Offset bursts
                    const xOff = (burstIndex - 2) * 10;
                    
                    x = xOff + radius * Math.cos(theta) * Math.sin(phi);
                    y = radius * Math.sin(theta) * Math.sin(phi);
                    z = radius * Math.cos(phi);
                }

                targetPositions[i3] = x;
                targetPositions[i3+1] = y;
                targetPositions[i3+2] = z;
            }
        }

        // --- 5. ANIMATION LOOP ---
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            calculateTargets(time);

            const positionsAttribute = geometry.attributes.position;
            const currentPositions = positionsAttribute.array;

            // Smoothly interpolate current position to target position
            const lerpSpeed = 0.1;

            for (let i = 0; i < config.particleCount * 3; i++) {
                currentPositions[i] += (targetPositions[i] - currentPositions[i]) * lerpSpeed;
            }

            positionsAttribute.needsUpdate = true;

            // Slowly rotate the whole system
            particles.rotation.y += 0.002;

            renderer.render(scene, camera);
        }
        animate();

        // --- 6. HAND TRACKING LOGIC ---
        const videoElement = document.getElementById('video-feed');
        const statusText = document.getElementById('status-text');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                config.handDetected = true;
                
                // Process the first hand detected for simplicity
                const landmarks = results.multiHandLandmarks[0];
                
                // Calculate "Openness" (Tension)
                // Measure distance between Wrist(0) and Middle Finger Tip(12)
                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const indexTip = landmarks[8];
                
                // Simple Euclidean distance (Z is ignored for rough estimate, or included)
                // MediaPipe coords are 0-1.
                const dist = Math.sqrt(
                    Math.pow(middleTip.x - wrist.x, 2) + 
                    Math.pow(middleTip.y - wrist.y, 2)
                );

                // Empirically: Closed fist ~0.15, Open palm ~0.5 to 0.6
                // Map 0.15->0.5 to 0.0->1.0
                let t = (dist - 0.2) / 0.35;
                t = Math.max(0, Math.min(1, t)); // Clamp
                
                // Smooth the tension value
                config.handTension += (t - config.handTension) * 0.2;

            } else {
                config.handDetected = false;
                // Slowly return to default if hand lost
                config.handTension += (0.5 - config.handTension) * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1, // 0 is fastest, 1 is balanced
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // --- 7. UI INTERACTIONS ---
        document.getElementById('start-btn').addEventListener('click', async () => {
            statusText.innerText = "Initializing Camera...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
                videoElement.srcObject = stream;
                videoElement.play();
                
                const cameraUtils = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });
                
                cameraUtils.start();
                
                document.getElementById('start-overlay').style.display = 'none';
                document.getElementById('ui-container').style.display = 'flex';

            } catch (err) {
                console.error(err);
                statusText.innerText = "Error accessing camera. Ensure you are on HTTPS.";
                alert("Camera access denied or not available. Please allow camera permissions.");
            }
        });

        // Template Switcher
        const buttons = document.querySelectorAll('.mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                // Remove active class
                buttons.forEach(b => b.classList.remove('active'));
                // Add active
                e.target.classList.add('active');
                // Set mode
                config.mode = e.target.getAttribute('data-mode');
            });
        });

        // Color Picker
        const colorPicker = document.getElementById('color-picker');
        colorPicker.addEventListener('input', (e) => {
            config.baseColor.set(e.target.value);
            material.color = config.baseColor;
        });

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>